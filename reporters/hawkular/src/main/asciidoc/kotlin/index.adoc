= Hawkular Metrics

<p>
This project is an implementation of the Vert.x Metrics Service Provider Interface (SPI): metrics built from Vert.x
events will be sent to Hawkular, an http://www.hawkular.org[open source monitoring and management solution].
<p>
== Features
<p>
* Vert.x core tools monitoring: TCP/HTTP client and servers, `link:../../apidocs/io/vertx/core/datagram/DatagramSocket.html[DatagramSocket]`,
`link:../../apidocs/io/vertx/core/eventbus/EventBus.html[EventBus]` and handlers
* User defined metrics via an `link:../../apidocs/io/vertx/core/eventbus/EventBus.html[EventBus]` bridge.
<p>
== Prerequisites
<p>
Follow the http://www.hawkular.org/hawkular-services/docs/quickstart-guide/[instructions to get Hawkular up and running].
<p>
NOTE: You can use a standalone https://github.com/hawkular/hawkular-metrics[Hawkular Metrics] server as well.
<p>
== Getting started
<p>
The _vertx-hawkular-metrics_ module must be present in the classpath.
<p>
Maven users should add this to their project POM file:
<p>
[source,xml,subs="+attributes"]
----
<dependency>
<groupId>io.vertx</groupId>
<artifactId>vertx-hawkular-metrics</artifactId>
<version>3.5.0-SNAPSHOT</version>
</dependency>
----
<p>
And Gradle users, to their build file:
<p>
[source,groovy,subs="+attributes"]
----
compile 'io.vertx:vertx-hawkular-metrics:3.5.0-SNAPSHOT'
----
<p>
Vert.x does not enable SPI implementations by default. You must enable metric collection in the Vert.x options:
<p>
[source,kotlin]
----
var vertx = Vertx.vertx(VertxOptions(
  metricsOptions = VertxHawkularOptions(
    enabled = true)))

----
<p>
== Configuration
<p>
=== Remote Hawkular server
<p>
By default, _vertx-hawkular-metrics_ sends metrics to a Hawkular server listening on `localhost` port `8080`.
But in production, the Hawkular server will likely run on a separate machine:
<p>
[source,kotlin]
----
var vertx = Vertx.vertx(VertxOptions(
  metricsOptions = VertxHawkularOptions(
    enabled = true,
    host = "hawkular.example.com",
    port = 8080)))

----
<p>
=== Tenant selection
<p>
Hawkular Metrics is a multi-tenant solution, and _vertx-hawkular-metrics_ can send metrics for a tenant other than `default`:
<p>
[source,kotlin]
----
var vertx = Vertx.vertx(VertxOptions(
  metricsOptions = VertxHawkularOptions(
    enabled = true,
    tenant = "sales-department")))

----
<p>
=== Connecting to a Hawkular server
<p>
Requests sent to a Hawkular server must be authenticated and tenant must be set to `hawkular`:
<p>
[source,kotlin]
----
var vertx = Vertx.vertx(VertxOptions(
  metricsOptions = VertxHawkularOptions(
    enabled = true,
    tenant = "hawkular",
    authenticationOptions = AuthenticationOptions(
      enabled = true,
      id = "username",
      secret = "password"))))

----
<p>
=== Openshift Metrics token authentication
<p>
When working with Openshift's internal Metrics server, you can configure token authentication with a custom HTTP header:
<p>
[source,kotlin]
----
var vertx = Vertx.vertx(VertxOptions(
  metricsOptions = VertxHawkularOptions(
    enabled = true,
    tenant = "my-namespace",
    httpHeaders = json {
      obj("Authorization" to "Bearer xkjdksf9890-shjkjhkjlkjlk")
    })))

----
<p>
=== HTTPS and other HTTP related options
<p>
_vertx-hawkular-metrics_ communicates with the Hawkular server over HTTP. In order to communicate over HTTPS, set the
`ssl` flag to true:
<p>
[source,kotlin]
----
var vertx = Vertx.vertx(VertxOptions(
  metricsOptions = VertxHawkularOptions(
    enabled = true,
    host = "hawkular.example.com",
    port = 443,
    httpOptions = HttpClientOptions(
      ssl = true))))

----
<p>
NOTE: The usual `link:../../apidocs/io/vertx/core/http/HttpClientOptions.html[HttpClientOptions]` properties can be used for SSL setup or client
tuning.
<p>
=== Metric tags
<p>
http://www.hawkular.org/hawkular-metrics/docs/user-guide/#_tagging[Tags] can be applied to metrics:
<p>
[source,kotlin]
----
var vertx = Vertx.vertx(VertxOptions(
  metricsOptions = VertxHawkularOptions(
    enabled = true,
    tags = json {
      obj(
        "dc" to "mars01",
        "rack" to "web-paca",
        "host" to "host13"
      )
    })))

----
<p>
_vertx-hawkular-metrics_ maintains a LRU cache of tagged metrics to avoid repeating tagging requests.
The cache size can be configured and defaults to `4096` metric names.
<p>
It is also possible to apply tags to a specific set of metrics defined via exact match or regex match:
<p>
[source,kotlin]
----
var vertx = Vertx.vertx(VertxOptions(
  metricsOptions = VertxHawkularOptions(
    enabled = true,
    metricTagsMatches = listOf(MetricTagsMatch(
      value = "myapp.foo.my-metric",
      tags = json {
        obj("myapp" to "foo")
      }), MetricTagsMatch(
      type = MatchType.REGEX,
      value = ".*\\.foo\\.*",
      tags = json {
        obj("myapp" to "foo")
      })))))

----
<p>
WARNING: If you use regex match, a wrong regex can potentially match a lot of metrics.
<p>
NOTE: When evaluating tags to apply, metric specific tags have higher priority than global tags.
In other words, a metric specific tag may overwrite a global tag.
<p>
Please refer to `link:../../apidocs/io/vertx/ext/metric/reporters/hawkular/VertxHawkularOptions.html[VertxHawkularOptions]` for an exhaustive list of options.
<p>
== Vert.x core tools metrics
<p>
This section lists all the metrics generated by monitoring the Vert.x core tools.
<p>
=== Net Client
<p>
[cols="15,50,35", options="header"]
|===
|Metric type
|Metric name
|Description
<p>
|Gauge
|`vertx.net.client.<host>:<port>.connections`
|Number of connections to the remote host currently opened.
<p>
|Counter
|`vertx.net.client.<host>:<port>.bytesReceived`
|Total number of bytes received from the remote host.
<p>
|Counter
|`vertx.net.client.<host>:<port>.bytesSent`
|Total number of bytes sent to the remote host.
<p>
|Counter
|`vertx.net.client.<host>:<port>.errorCount`
|Total number of errors.
<p>
|===
<p>
=== HTTP Client
<p>
[cols="15,50,35", options="header"]
|===
|Metric type
|Metric name
|Description
<p>
|Gauge
|`vertx.http.client.<host>:<port>.connections`
|Number of connections to the remote host currently opened.
<p>
|Counter
|`vertx.http.client.<host>:<port>.bytesReceived`
|Total number of bytes received from the remote host.
<p>
|Counter
|`vertx.http.client.<host>:<port>.bytesSent`
|Total number of bytes sent to the remote host.
<p>
|Counter
|`vertx.http.client.<host>:<port>.errorCount`
|Total number of errors.
<p>
|Gauge
|`vertx.http.client.<host>:<port>.requests`
|Number of requests waiting for a response.
<p>
|Counter
|`vertx.http.client.<host>:<port>.requestCount`
|Total number of requests sent.
<p>
|Counter
|`vertx.http.client.<host>:<port>.responseTime`
|Cumulated response time.
<p>
|Gauge
|`vertx.http.client.<host>:<port>.wsConnections`
|Number of websockets currently opened.
<p>
|===
<p>
=== Datagram socket
<p>
[cols="15,50,35", options="header"]
|===
|Metric type
|Metric name
|Description
<p>
|Counter
|`vertx.datagram.<host>:<port>.bytesReceived`
|Total number of bytes received on the `<host>:<port>` listening address.
<p>
|Counter
|`vertx.datagram.<host>:<port>.bytesSent`
|Total number of bytes sent to the remote host.
<p>
|Counter
|`vertx.datagram.errorCount`
|Total number of errors.
<p>
|===
<p>
=== Net Server
<p>
[cols="15,50,35", options="header"]
|===
|Metric type
|Metric name
|Description
<p>
|Gauge
|`vertx.net.server.<host>:<port>.connections`
|Number of opened connections to the Net Server listening on the `<host>:<port>` address.
<p>
|Counter
|`vertx.net.server.<host>:<port>.bytesReceived`
|Total number of bytes received by the Net Server listening on the `<host>:<port>` address.
<p>
|Counter
|`vertx.net.server.<host>:<port>.bytesSent`
|Total number of bytes sent to the Net Server listening on the `<host>:<port>` address.
<p>
|Counter
|`vertx.net.server.<host>:<port>.errorCount`
|Total number of errors.
<p>
|===
<p>
=== HTTP Server
<p>
[cols="15,50,35", options="header"]
|===
|Metric type
|Metric name
|Description
<p>
|Gauge
|`vertx.http.server.<host>:<port>.connections`
|Number of opened connections to the HTTP Server listening on the `<host>:<port>` address.
<p>
|Counter
|`vertx.http.server.<host>:<port>.bytesReceived`
|Total number of bytes received by the HTTP Server listening on the `<host>:<port>` address.
<p>
|Counter
|`vertx.http.server.<host>:<port>.bytesSent`
|Total number of bytes sent to the HTTP Server listening on the `<host>:<port>` address.
<p>
|Counter
|`vertx.http.server.<host>:<port>.errorCount`
|Total number of errors.
<p>
|Gauge
|`vertx.http.client.<host>:<port>.requests`
|Number of requests being processed.
<p>
|Counter
|`vertx.http.client.<host>:<port>.requestCount`
|Total number of requests processed.
<p>
|Counter
|`vertx.http.client.<host>:<port>.processingTime`
|Cumulated request processing time.
<p>
|Gauge
|`vertx.http.client.<host>:<port>.wsConnections`
|Number of websockets currently opened.
<p>
|===
<p>
=== Event Bus
<p>
[cols="15,50,35", options="header"]
|===
|Metric type
|Metric name
|Description
<p>
|Gauge
|`vertx.eventbus.handlers`
|Number of event bus handlers.
<p>
|Counter
|`vertx.eventbus.errorCount`
|Total number of errors.
<p>
|Counter
|`vertx.eventbus.bytesWritten`
|Total number of bytes sent while sending messages to event bus cluster peers.
<p>
|Counter
|`vertx.eventbus.bytesRead`
|Total number of bytes received while reading messages from event bus cluster peers.
<p>
|Gauge
|`vertx.eventbus.pending`
|Number of messages not processed yet. One message published will count for `N` pending if `N` handlers
are registered to the corresponding address.
<p>
|Gauge
|`vertx.eventbus.pendingLocal`
|Like `vertx.eventbus.pending`, for local messages only.
<p>
|Gauge
|`vertx.eventbus.pendingRemote`
|Like `vertx.eventbus.pending`, for remote messages only.
<p>
|Counter
|`vertx.eventbus.publishedMessages`
|Total number of messages published (publish / subscribe).
<p>
|Counter
|`vertx.eventbus.publishedLocalMessages`
|Like `vertx.eventbus.publishedMessages`, for local messages only.
<p>
|Counter
|`vertx.eventbus.publishedRemoteMessages`
|Like `vertx.eventbus.publishedMessages`, for remote messages only.
<p>
|Counter
|`vertx.eventbus.sentMessages`
|Total number of messages sent (point-to-point).
<p>
|Counter
|`vertx.eventbus.sentLocalMessages`
|Like `vertx.eventbus.sentMessages`, for local messages only.
<p>
|Counter
|`vertx.eventbus.sentRemoteMessages`
|Like `vertx.eventbus.sentMessages`, for remote messages only.
<p>
|Counter
|`vertx.eventbus.receivedMessages`
|Total number of messages received.
<p>
|Counter
|`vertx.eventbus.receivedLocalMessages`
|Like `vertx.eventbus.receivedMessages`, for remote messages only.
<p>
|Counter
|`vertx.eventbus.receivedRemoteMessages`
|Like `vertx.eventbus.receivedMessages`, for remote messages only.
<p>
|Counter
|`vertx.eventbus.deliveredMessages`
|Total number of messages delivered to handlers.
<p>
|Counter
|`vertx.eventbus.deliveredLocalMessages`
|Like `vertx.eventbus.deliveredMessages`, for remote messages only.
<p>
|Counter
|`vertx.eventbus.deliveredRemoteMessages`
|Like `vertx.eventbus.deliveredMessages`, for remote messages only.
<p>
|Counter
|`vertx.eventbus.replyFailures`
|Total number of message reply failures.
<p>
|Counter
|`vertx.eventbus.<address>.processingTime`
|Cumulated processing time for handlers listening to the `address`.
<p>
|===
<p>
== Vert.x pool metrics
<p>
This section lists all the metrics generated by monitoring Vert.x pools.
<p>
There are two types currently supported:
<p>
* _worker_ (see `link:../../apidocs/io/vertx/core/WorkerExecutor.html[WorkerExecutor]`)
* _datasource_ (created with Vert.x JDBC client)
<p>
NOTE: Vert.x creates two worker pools upfront, _vert.x-worker-thread_ and _vert.x-internal-blocking_.
<p>
All metrics are prefixed with `<type>.<name>.`. For example, `worker.vert.x-internal-blocking.`.
<p>
[cols="15,50,35", options="header"]
|===
|Metric type
|Metric name
|Description
<p>
|Counter
|`vertx.pool.<type>.<name>.delay`
|Cumulated time waiting for a resource (queue time).
<p>
|Gauge
|`vertx.pool.<type>.<name>.queued`
|Current number of elements waiting for a resource.
<p>
|Counter
|`vertx.pool.<type>.<name>.queueCount`
|Total number of elements queued.
<p>
|Counter
|`vertx.pool.<type>.<name>.usage`
|Cumulated time using a resource (i.e. processing time for worker pools).
<p>
|Gauge
|`vertx.pool.<type>.<name>.inUse`
|Current number of resources used.
<p>
|Counter
|`vertx.pool.<type>.<name>.completed`
|Total number of elements done with the resource (i.e. total number of tasks executed for worker pools).
<p>
|Gauge
|`vertx.pool.<type>.<name>.maxPoolSize`
|Maximum pool size, only present if it could be determined.
<p>
|Gauge
|`vertx.pool.<type>.<name>.inUse`
|Pool usage ratio, only present if maximum pool size could be determined.
<p>
|===
<p>
== Verticle metrics
<p>
[cols="15,50,35", options="header"]
|===
|Metric type
|Metric name
|Description
<p>
|Gauge
|`vertx.verticle.<name>`
|Number of verticle instances deployed.
<p>
|===
<p>
== User defined metrics
<p>
Users can send their own metrics to the Hawkular server. In order to do so, the event bus metrics bridge must be
enabled:
<p>
[source,kotlin]
----
Code not translatable
----
<p>
By default, the metrics bus handler is listening to the `hawkular.metrics` address. But the bridge address
can be configured:
<p>
[source,kotlin]
----
Code not translatable
----
<p>
The metrics bridge handler expects messages in the JSON format. The JSON object must at least provide a metric
`id` and a numerical `value`:
<p>
[source,kotlin]
----
var message = json {
  obj(
    "id" to "myapp.files.opened",
    "value" to 7
  )
}
vertx.eventBus().publish("hawkular.metrics", message)

----
<p>
The handler will assume the metric is a gauge and will assign a timestamp corresponding to the time when the message was processed.
If the metric is a counter or availability, or if you prefer explicit configuration, set the `type` and/or `timestamp` attributes:
<p>
[source,kotlin]
----
var counterMetric = json {
  obj(
    "id" to "myapp.files.opened",
    "type" to "counter",
    "timestamp" to 189898098098908L,
    "value" to 7
  )
}
vertx.eventBus().publish("hawkular.metrics", counterMetric)

var availabilityMetric = json {
  obj(
    "id" to "myapp.mysubsystem.status",
    "type" to "availability",
    "value" to "up"
  )
}
vertx.eventBus().publish("hawkular.metrics", availabilityMetric)

----
<p>
NOTE: Hawkular understands all timestamps as milliseconds since January 1, 1970, 00:00:00 UTC.