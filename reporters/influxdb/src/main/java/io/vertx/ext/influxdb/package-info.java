/*
 * Copyright (c) 2011-2017 The original author or authors
 * ------------------------------------------------------
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * and Apache License v2.0 which accompanies this distribution.
 *
 *     The Eclipse Public License is available at
 *     http://www.eclipse.org/legal/epl-v10.html
 *
 *     The Apache License v2.0 is available at
 *     http://www.opensource.org/licenses/apache2.0.php
 *
 * You may elect to redistribute this code under either of these licenses.
 */

/**
 * = InfluxDb Metrics
 * <p>
 * This project is an implementation of the Vert.x Metrics Service Provider Interface (SPI): metrics built from Vert.x
 * events will be sent to InfluxDb, an https://github.com/influxdata/influxdb[open source time series database].
 * <p>
 * == Features
 * <p>
 * * Vert.x core tools monitoring: TCP/HTTP client and servers, {@link io.vertx.core.datagram.DatagramSocket},
 * {@link io.vertx.core.eventbus.EventBus} and handlers
 * * User defined metrics via an {@link io.vertx.core.eventbus.EventBus} bridge.
 * <p>
 * == Prerequisites
 * <p>
 * Follow the https://docs.influxdata.com/influxdb/v1.2/introduction/getting_started/[instructions to get InfluxDb up and running].
 * <p>
 * NOTE: You can use a standalone InfluxDb  server as well.
 * <p>
 * == Getting started
 * <p>
 * The _${maven.artifactId}_ module must be present in the classpath.
 * <p>
 * Maven users should add this to their project POM file:
 * <p>
 * [source,xml,subs="+attributes"]
 * ----
 * <dependency>
 * <groupId>${maven.groupId}</groupId>
 * <artifactId>${maven.artifactId}</artifactId>
 * <version>${maven.version}</version>
 * </dependency>
 * ----
 * <p>
 * And Gradle users, to their build file:
 * <p>
 * [source,groovy,subs="+attributes"]
 * ----
 * compile '${maven.groupId}:${maven.artifactId}:${maven.version}'
 * ----
 * <p>
 * <p>
 * Please refer to {@link io.vertx.ext.influxdb.VertxInfluxDbOptions} for an exhaustive list of options.
 * <p>
 * == Vert.x core tools metrics
 * <p>
 * This section lists all the metrics generated by monitoring the Vert.x core tools.
 * <p>
 * === Net Client
 * <p>
 * [cols="15,50,35", options="header"]
 * |===
 * |Metric type
 * |Metric name
 * |Description
 * <p>
 * |Gauge
 * |{@code vertx.net.client.<host>:<port>.connections}
 * |Number of connections to the remote host currently opened.
 * <p>
 * |Counter
 * |{@code vertx.net.client.<host>:<port>.bytesReceived}
 * |Total number of bytes received from the remote host.
 * <p>
 * |Counter
 * |{@code vertx.net.client.<host>:<port>.bytesSent}
 * |Total number of bytes sent to the remote host.
 * <p>
 * |Counter
 * |{@code vertx.net.client.<host>:<port>.errorCount}
 * |Total number of errors.
 * <p>
 * |===
 * <p>
 * === HTTP Client
 * <p>
 * [cols="15,50,35", options="header"]
 * |===
 * |Metric type
 * |Metric name
 * |Description
 * <p>
 * |Gauge
 * |{@code vertx.http.client.<host>:<port>.connections}
 * |Number of connections to the remote host currently opened.
 * <p>
 * |Counter
 * |{@code vertx.http.client.<host>:<port>.bytesReceived}
 * |Total number of bytes received from the remote host.
 * <p>
 * |Counter
 * |{@code vertx.http.client.<host>:<port>.bytesSent}
 * |Total number of bytes sent to the remote host.
 * <p>
 * |Counter
 * |{@code vertx.http.client.<host>:<port>.errorCount}
 * |Total number of errors.
 * <p>
 * |Gauge
 * |{@code vertx.http.client.<host>:<port>.requests}
 * |Number of requests waiting for a response.
 * <p>
 * |Counter
 * |{@code vertx.http.client.<host>:<port>.requestCount}
 * |Total number of requests sent.
 * <p>
 * |Counter
 * |{@code vertx.http.client.<host>:<port>.responseTime}
 * |Cumulated response time.
 * <p>
 * |Gauge
 * |{@code vertx.http.client.<host>:<port>.wsConnections}
 * |Number of websockets currently opened.
 * <p>
 * |===
 * <p>
 * === Datagram socket
 * <p>
 * [cols="15,50,35", options="header"]
 * |===
 * |Metric type
 * |Metric name
 * |Description
 * <p>
 * |Counter
 * |{@code vertx.datagram.<host>:<port>.bytesReceived}
 * |Total number of bytes received on the {@code <host>:<port>} listening address.
 * <p>
 * |Counter
 * |{@code vertx.datagram.<host>:<port>.bytesSent}
 * |Total number of bytes sent to the remote host.
 * <p>
 * |Counter
 * |{@code vertx.datagram.errorCount}
 * |Total number of errors.
 * <p>
 * |===
 * <p>
 * === Net Server
 * <p>
 * [cols="15,50,35", options="header"]
 * |===
 * |Metric type
 * |Metric name
 * |Description
 * <p>
 * |Gauge
 * |{@code vertx.net.server.<host>:<port>.connections}
 * |Number of opened connections to the Net Server listening on the {@code <host>:<port>} address.
 * <p>
 * |Counter
 * |{@code vertx.net.server.<host>:<port>.bytesReceived}
 * |Total number of bytes received by the Net Server listening on the {@code <host>:<port>} address.
 * <p>
 * |Counter
 * |{@code vertx.net.server.<host>:<port>.bytesSent}
 * |Total number of bytes sent to the Net Server listening on the {@code <host>:<port>} address.
 * <p>
 * |Counter
 * |{@code vertx.net.server.<host>:<port>.errorCount}
 * |Total number of errors.
 * <p>
 * |===
 * <p>
 * === HTTP Server
 * <p>
 * [cols="15,50,35", options="header"]
 * |===
 * |Metric type
 * |Metric name
 * |Description
 * <p>
 * |Gauge
 * |{@code vertx.http.server.<host>:<port>.connections}
 * |Number of opened connections to the HTTP Server listening on the {@code <host>:<port>} address.
 * <p>
 * |Counter
 * |{@code vertx.http.server.<host>:<port>.bytesReceived}
 * |Total number of bytes received by the HTTP Server listening on the {@code <host>:<port>} address.
 * <p>
 * |Counter
 * |{@code vertx.http.server.<host>:<port>.bytesSent}
 * |Total number of bytes sent to the HTTP Server listening on the {@code <host>:<port>} address.
 * <p>
 * |Counter
 * |{@code vertx.http.server.<host>:<port>.errorCount}
 * |Total number of errors.
 * <p>
 * |Gauge
 * |{@code vertx.http.client.<host>:<port>.requests}
 * |Number of requests being processed.
 * <p>
 * |Counter
 * |{@code vertx.http.client.<host>:<port>.requestCount}
 * |Total number of requests processed.
 * <p>
 * |Counter
 * |{@code vertx.http.client.<host>:<port>.processingTime}
 * |Cumulated request processing time.
 * <p>
 * |Gauge
 * |{@code vertx.http.client.<host>:<port>.wsConnections}
 * |Number of websockets currently opened.
 * <p>
 * |===
 * <p>
 * === Event Bus
 * <p>
 * [cols="15,50,35", options="header"]
 * |===
 * |Metric type
 * |Metric name
 * |Description
 * <p>
 * |Gauge
 * |{@code vertx.eventbus.handlers}
 * |Number of event bus handlers.
 * <p>
 * |Counter
 * |{@code vertx.eventbus.errorCount}
 * |Total number of errors.
 * <p>
 * |Counter
 * |{@code vertx.eventbus.bytesWritten}
 * |Total number of bytes sent while sending messages to event bus cluster peers.
 * <p>
 * |Counter
 * |{@code vertx.eventbus.bytesRead}
 * |Total number of bytes received while reading messages from event bus cluster peers.
 * <p>
 * |Gauge
 * |{@code vertx.eventbus.pending}
 * |Number of messages not processed yet. One message published will count for {@code N} pending if {@code N} handlers
 * are registered to the corresponding address.
 * <p>
 * |Gauge
 * |{@code vertx.eventbus.pendingLocal}
 * |Like {@code vertx.eventbus.pending}, for local messages only.
 * <p>
 * |Gauge
 * |{@code vertx.eventbus.pendingRemote}
 * |Like {@code vertx.eventbus.pending}, for remote messages only.
 * <p>
 * |Counter
 * |{@code vertx.eventbus.publishedMessages}
 * |Total number of messages published (publish / subscribe).
 * <p>
 * |Counter
 * |{@code vertx.eventbus.publishedLocalMessages}
 * |Like {@code vertx.eventbus.publishedMessages}, for local messages only.
 * <p>
 * |Counter
 * |{@code vertx.eventbus.publishedRemoteMessages}
 * |Like {@code vertx.eventbus.publishedMessages}, for remote messages only.
 * <p>
 * |Counter
 * |{@code vertx.eventbus.sentMessages}
 * |Total number of messages sent (point-to-point).
 * <p>
 * |Counter
 * |{@code vertx.eventbus.sentLocalMessages}
 * |Like {@code vertx.eventbus.sentMessages}, for local messages only.
 * <p>
 * |Counter
 * |{@code vertx.eventbus.sentRemoteMessages}
 * |Like {@code vertx.eventbus.sentMessages}, for remote messages only.
 * <p>
 * |Counter
 * |{@code vertx.eventbus.receivedMessages}
 * |Total number of messages received.
 * <p>
 * |Counter
 * |{@code vertx.eventbus.receivedLocalMessages}
 * |Like {@code vertx.eventbus.receivedMessages}, for remote messages only.
 * <p>
 * |Counter
 * |{@code vertx.eventbus.receivedRemoteMessages}
 * |Like {@code vertx.eventbus.receivedMessages}, for remote messages only.
 * <p>
 * |Counter
 * |{@code vertx.eventbus.deliveredMessages}
 * |Total number of messages delivered to handlers.
 * <p>
 * |Counter
 * |{@code vertx.eventbus.deliveredLocalMessages}
 * |Like {@code vertx.eventbus.deliveredMessages}, for remote messages only.
 * <p>
 * |Counter
 * |{@code vertx.eventbus.deliveredRemoteMessages}
 * |Like {@code vertx.eventbus.deliveredMessages}, for remote messages only.
 * <p>
 * |Counter
 * |{@code vertx.eventbus.replyFailures}
 * |Total number of message reply failures.
 * <p>
 * |Counter
 * |{@code vertx.eventbus.<address>.processingTime}
 * |Cumulated processing time for handlers listening to the {@code address}.
 * <p>
 * |===
 * <p>
 * == Vert.x pool metrics
 * <p>
 * This section lists all the metrics generated by monitoring Vert.x pools.
 * <p>
 * There are two types currently supported:
 * <p>
 * * _worker_ (see {@link io.vertx.core.WorkerExecutor})
 * * _datasource_ (created with Vert.x JDBC client)
 * <p>
 * Note that Vert.x creates two worker pools upfront, _vert.x-worker-thread_ and _vert.x-internal-blocking_.
 * <p>
 * All metrics are prefixed with {@code <type>.<name>.}. For example, {@code worker.vert.x-internal-blocking.}.
 * <p>
 * [cols="15,50,35", options="header"]
 * |===
 * |Metric type
 * |Metric name
 * |Description
 * <p>
 * |Counter
 * |{@code vertx.pool.<type>.<name>.delay}
 * |Cumulated time waiting for a resource (queue time).
 * <p>
 * |Gauge
 * |{@code vertx.pool.<type>.<name>.queued}
 * |Current number of elements waiting for a resource.
 * <p>
 * |Counter
 * |{@code vertx.pool.<type>.<name>.queueCount}
 * |Total number of elements queued.
 * <p>
 * |Counter
 * |{@code vertx.pool.<type>.<name>.usage}
 * |Cumulated time using a resource (i.e. processing time for worker pools).
 * <p>
 * |Gauge
 * |{@code vertx.pool.<type>.<name>.inUse}
 * |Current number of resources used.
 * <p>
 * |Counter
 * |{@code vertx.pool.<type>.<name>.completed}
 * |Total number of elements done with the resource (i.e. total number of tasks executed for worker pools).
 * <p>
 * |Gauge
 * |{@code vertx.pool.<type>.<name>.maxPoolSize}
 * |Maximum pool size, only present if it could be determined.
 * <p>
 * |Gauge
 * |{@code vertx.pool.<type>.<name>.inUse}
 * |Pool usage ratio, only present if maximum pool size could be determined.
 * <p>
 * |===
 * <p>
 * == User defined metrics
 * <p>
 * Users can send their own metrics to the InfluxDb server. In order to do so, the event bus metrics bridge must be
 * enabled:
 * <p>
 * [source,$lang]
 * ----
 * {@link examples.MetricsExamples#enableMetricsBridge()}
 * ----
 * <p>
 * By default, the metrics bus handler is listening to the {@code influxdb.metrics} address. But the bridge address
 * can be configured:
 * <p>
 * [source,$lang]
 * ----
 * {@link examples.MetricsExamples#customMetricsBridgeAddress()}
 * ----
 * <p>
 * The metrics bridge handler expects messages in the JSON format. The JSON object must at least provide a metric
 * {@code id} and a numerical {@code value}:
 * <p>
 * [source,$lang]
 * ----
 * {@link examples.MetricsExamples#userDefinedMetric()}
 * ----
 * <p>
 * The handler will assume the metric is a gauge and will assign a timestamp corresponding to the time when the message was processed.
 * If the metric is a counter or availability, or if you prefer explicit configuration, set the {@code type} and/or {@code timestamp} attributes:
 * <p>
 * [source,$lang]
 * ----
 * {@link examples.MetricsExamples#userDefinedMetricExplicit()}
 * ----
 * <p>
 * Note that InfluxDb understands all timestamps as milliseconds since January 1, 1970, 00:00:00 UTC.
 */
@ModuleGen(name = "vertx-metric-reporters-influxdb", groupPackage = "io.vertx")
@Document(fileName = "index.adoc")
package io.vertx.ext.influxdb;

import io.vertx.codegen.annotations.ModuleGen;
import io.vertx.docgen.Document;
